import { toSimpleValidationErrors, resolveUrl, resolveMethod } from 'laravel-precognition';
import { useForm as usePrecognitiveForm, client } from 'laravel-precognition-react';
import { useForm as useInertiaForm } from '@inertiajs/react';
import { useRef } from 'react';
export { client };
export const useForm = (method, url, inputs, config = {}) => {
    const booted = useRef(false);
    /**
     * The Inertia form.
     */
    const inertiaForm = useInertiaForm(inputs);
    /**
     * The React form.
     */
    const precognitiveForm = usePrecognitiveForm(method, url, inputs, config);
    /**
     * The Inertia submit function.
     */
    const inertiaSubmit = inertiaForm.submit.bind(inertiaForm);
    /**
     * The Inertia reset function.
     */
    const inertiaReset = inertiaForm.reset.bind(inertiaForm);
    /**
     * The Inertia clear errors function.
     */
    const inertiaClearErrors = inertiaForm.clearErrors.bind(inertiaForm);
    /**
     * The Inertia set error function.
     */
    const inertiaSetError = inertiaForm.setError.bind(inertiaForm);
    /**
     * The Inertia set data function.
     */
    const inertiaSetData = inertiaForm.setData.bind(inertiaForm);
    /**
     * The Inertia trasform function.
     */
    const inertiaTransform = inertiaForm.transform.bind(inertiaForm);
    /**
     * The transform function.
     */
    const transformer = useRef((data) => data);
    if (!booted.current) {
        /**
         * Setup event listeners.
         */
        precognitiveForm.validator().on('errorsChanged', () => {
            inertiaClearErrors();
            inertiaSetError(
            // @ts-expect-error
            toSimpleValidationErrors(precognitiveForm.validator().errors()));
        });
        booted.current = true;
    }
    /**
     * Patch the form.
     */
    const form = Object.assign(inertiaForm, {
        validating: precognitiveForm.validating,
        touched: precognitiveForm.touched,
        touch(name) {
            precognitiveForm.touch(name);
            return form;
        },
        valid: precognitiveForm.valid,
        invalid: precognitiveForm.invalid,
        setData(key, value) {
            inertiaSetData(key, value);
            precognitiveForm.setData(key, value);
            return form;
        },
        clearErrors(...names) {
            inertiaClearErrors(...names);
            if (names.length === 0) {
                precognitiveForm.setErrors({});
            }
            else {
                names.forEach(precognitiveForm.forgetError);
            }
            return form;
        },
        reset(...names) {
            inertiaReset(...names);
            precognitiveForm.reset(...names);
        },
        setErrors(errors) {
            // @ts-expect-error
            precognitiveForm.setErrors(errors);
            return form;
        },
        setError(key, value) {
            form.setErrors({
                ...inertiaForm.errors,
                ...typeof value === 'undefined'
                    ? key
                    : { [key]: value },
            });
            return form;
        },
        forgetError(name) {
            precognitiveForm.forgetError(name);
            return form;
        },
        transform(callback) {
            inertiaTransform(callback);
            transformer.current = callback;
            return form;
        },
        validate(name, config) {
            precognitiveForm.setData(transformer.current(inertiaForm.data));
            if (typeof name === 'object' && !('target' in name)) {
                config = name;
                name = undefined;
            }
            if (typeof name === 'undefined') {
                precognitiveForm.validate(config);
            }
            else {
                precognitiveForm.validate(name, config);
            }
            return form;
        },
        setValidationTimeout(duration) {
            precognitiveForm.setValidationTimeout(duration);
            return form;
        },
        validateFiles() {
            precognitiveForm.validateFiles();
            return form;
        },
        submit(submitMethod = {}, submitUrl, submitOptions) {
            const isPatchedCall = typeof submitMethod !== 'string';
            submitOptions = isPatchedCall
                ? submitMethod
                : submitOptions;
            submitUrl = isPatchedCall
                ? resolveUrl(url)
                : submitUrl;
            submitMethod = isPatchedCall
                ? resolveMethod(method)
                : submitMethod;
            inertiaSubmit(submitMethod, submitUrl, {
                ...submitOptions,
                onError: (errors) => {
                    precognitiveForm.validator().setErrors(errors);
                    if (submitOptions.onError) {
                        return submitOptions.onError(errors);
                    }
                },
            });
        },
        validator: precognitiveForm.validator,
    });
    return form;
};
